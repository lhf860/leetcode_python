# coding:utf-8


"""
最长回文子串：二维动态规划的问题，提供了两种方案：1）动态规划  2）空心扩展法【优化方法】


问题定义：

    给定一个字符串s，找到s中最长的回文子串，回文子串即从头到尾正向读和从尾向头逆向读是完全相同的字符串。

思路：
1、找到子结构
   对于回文子串（前提）， 从头部和尾部去掉相同数量的字符，中间部分必定是一个回文字符串；
   对于回文子串来说，其子结构就是其中间部分仍未回文子串。
   所以可以用一个二维数组来表示本字符串的两位质检是否是回文子串，在初始化化时默认只有二维数组的对角线上是TRUE，其余默认为FALSE。

2、递推公式
   s=输入的字符串
   dp: 保存字符串两位之间是否是回文字符，数组内部每个数据是布尔类型
   当s[i]=s[j]时，就继续判断dp[i-1][j+1]是否是回文子串，如果是，那么s[i]到s[j]的子串就是回文串，再更新dp[i][j]为TRUE。
   dp[i][j]=s[i]==s[j]  and (dp[i+1][j-1] or j-i==1)

   遍历顺序：由于判断i到j之间是不是回文子串，要求第i+1到第j-1位是不是回文子串，因此在变量字符串的过程中，从后向前遍历，如此可以保证第i+1位到第j-1位是不是回文子串，避免重复计算。


"""


def longest_palindrome(s):

    right = left = 0
    dp = []

    # 初始化dp
    for i in range(len(s)):
        dp.append([False] * len(s))
        dp[i][i] = True

    i = len(s) - 2
    while i >= 0:
        j = i + 1
        while j < len(s):
            dp[i][j] = s[i]==s[j] and (dp[i+1][j-1] or j - i == 1)
            if dp[i][j] and right - left < j - i:
                right = j
                left = i
            j += 1
        i -= 1
    return s[left: right+1]








